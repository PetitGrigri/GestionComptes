<?php
namespace FGS\GestionComptesBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * CategorieMouvementFinancierRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class CategorieMouvementFinancierRepository extends EntityRepository
{

	/*
	 * Cette méthode permet de récupérer les catégories d'un utilisateur, sous la forme d'une liste pouvant contenir
	 * des enfants 
	 */
	public function getTreeCategoriesForUtilisateur($utilisateurId, $cmf=null, $allowCmfId = false)
	{

		$queryBuilder	=	$this->getCategoriesForUtilisateur($utilisateurId);
		
		
		if (($cmf != null) && ( in_array($cmf->getType(), array(CategorieMouvementFinancier::TYPE_DEPENSE, CategorieMouvementFinancier::TYPE_REVENU))))
		{
			$queryBuilder
				->andWhere('cmf.type = ?2')
				->setParameter('2', $cmf->getType());
		}
		
		if (($cmf != null) && ($cmf->getId() != null) && (!$allowCmfId))
		{
			$queryBuilder
				->andWhere('cmf.id != ?3')
				->setParameter('3', $cmf->getId());
		}

		$resultat	= $queryBuilder->getQuery()->getResult();

		for ($key= count($resultat)-1; $key >=0; $key--)
		{
			$ligne=$resultat[$key];

			if ($ligne->getParent() != null) 
			{
				$this->addChildrenAndSetParent($resultat, $ligne);
				unset($resultat[$key]);
			}
			
			if ($ligne->getChildrens() instanceof  \Doctrine\ORM\PersistentCollection)
			{
				$ligne->getChildrens()->setInitialized(true);
			}
		}

		return array_reverse($resultat);
	}
	
	public function decreaseOrdreAfter(\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $parent, $ordre)
	{
		//TODO passer ca en query builder
		$this->_em
			->createQuery('
				UPDATE 		FGSGestionComptesBundle:CategorieMouvementFinancier cmf
				SET  		cmf.ordre	=	cmf.ordre - 1 
				WHERE 		cmf.parent 	= 	?1
				AND			cmf.ordre 	>	?2
				')
			->setParameter('1', $parent)
			->setParameter('2', $ordre)
			->execute();
	}
	
	public function increseOrdrePredecessor(\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $cmf)
	{
		$queryBuilder	= $this->_em->createQueryBuilder()
							->update('\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier', 'cmf')
							->set('cmf.ordre', 	'cmf.ordre+1')
							->where('cmf.ordre = ?1')
							->setParameter('1', $cmf->getOrdre()-1);
		
		return $this->addParentCondition($queryBuilder, $cmf)->getQuery()->getResult();
	}
	
	public function decreaseOrdreSuccessor(\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $cmf)
	{
			$queryBuilder	= $this->_em->createQueryBuilder()
								->update('\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier', 'cmf')
								->set('cmf.ordre', 	'cmf.ordre-1')
								->where('cmf.ordre = ?1')
								->setParameter('1', $cmf->getOrdre()+1);
			
			return $this->addParentCondition($queryBuilder, $cmf)->getQuery()->execute();
	}
	
	
	/*
	 * Cette méthode permet de renvoyer les catégories d'un utilisateur sous la forme d'une liste (array).
	 * Ici les catégories n'auront pas d'enfant, mais plus on "s'enfoncera dans l'arborscence, et plus le level de la catégorie sera élevé
	 * allowCmfId permet d'éviter qu'une Cmf apparaisse dans une liste
	 */
	public function getFlatTreeCategories($utilisateurId, $cmf=null, $allowCmfId=false)
	{
		return $this->flatChildren($this->getTreeCategoriesForUtilisateur($utilisateurId, $cmf, $allowCmfId));
	}
	
	
	
	


	/**
	 * Permet de récupérer la CatégorieMouvementFinancier recherchée ainsi que tout ses enfants (en récursif) dans une seule liste
	 * L'array renvoyé permettra d'éviter de parcourir les enfants du Cmf recherché dans le controlleur en récursif
	 */
	public function getFlatTreeCategoriesForCmf($cmf)
	{
		//Récupération de la Catégorie et de tout ses enfants (en récursif)
		$searchCmf	= $this->getCmfAndChildrensFor($this->getTreeCategoriesForUtilisateur($cmf->getUtilisateur()->getId()), $cmf);
		
		//rénvoie une liste contenant le Cmf recherche et tout ses enfants
		return ($searchCmf != null) ? $this->flatChildren(array($searchCmf)) : null;
	}
	
	
	/**
	 * Cette méthode permet de supprimer les CatégoriesMouvementFinancier à partir d'une liste d'identifiant 
	 * de CategorieMouvementFinancier. (Méthode plus rapide que l'utilisation d'un cascade remove)
	 * 
	 * @param array $listeCmfIdASupprimer
	 * @return \Doctrine\ORM\mixed
	 */
	public function removeCmfFromIdList(array $listeCmfIdASupprimer)
	{
		$qb			= $this->_em->createQueryBuilder();
		$conditions	= $qb->expr()->in('cmf.id', $listeCmfIdASupprimer);
		
		$qb->update('FGSGestionComptesBundle:CategorieMouvementFinancier', 'cmf')
			->set('cmf.parent', 'NULL')
			->where($conditions)
			->getQuery()
			->getResult();
		
		$qb->delete('FGSGestionComptesBundle:CategorieMouvementFinancier', 'cmf')
			->where($conditions);
		
		return $qb->getQuery()->getResult();
	}
	
	private function getCmfAndChildrensFor($listeCmf, $searchCmf)
	{
		foreach($listeCmf as $cmf)
		{
			if ($cmf->getId() == $searchCmf->getId())
			{
				return $cmf;
			}
			
			$searchCmfInChildren	= $this->getCmfAndChildrensFor($cmf->getChildrens(), $searchCmf);
			
			if ($searchCmfInChildren != null)
			{
				return $searchCmfInChildren;
			}
		}
	}

	
	
	/**
	 * Permet d'ajouter en condition le parent d'une CatégorieMouvementFinancier
	 * 
	 * @param \Doctrine\ORM\QueryBuilder $queryBuilder
	 * @param \FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $cmf
	 * @return \Doctrine\ORM\QueryBuilder
	 */
	private function addParentCondition(\Doctrine\ORM\QueryBuilder $queryBuilder, $cmf)
	{
		if ($cmf->getParent() == null)
		{
			$queryBuilder
				->andWhere('cmf.parent is NULL');
		}
		else
		{
			$queryBuilder
				->andWhere('cmf.parent = ?2')
				->setParameter('2', $cmf->getParent());
		}
		return $queryBuilder;
	}
	

	

	

	private function getCategoriesForUtilisateur($utilisateurId)
	{
		return $this->_em->createQueryBuilder()
			->select('cmf')
			->from('FGSGestionComptesBundle:CategorieMouvementFinancier', 'cmf')
			->leftJoin('cmf.utilisateur', 'u')
			->addOrderBy('cmf.parent', 'ASC')
			->addOrderBy('cmf.ordre', 'DESC')
			->andWhere('u.id = ?1')
			->setParameter('1', $utilisateurId);
	}

	private function flatChildren($treeCategorie, $level = 0)
	{
		$futurResultat = array();

		foreach ($treeCategorie as $categorie)
		{
			if ($categorie->hasChildren())
			{

				//echo $categorie->getLibelle(). ' a un enfant (level : '.$level.')<br/>';
				$categorie->setLevel($level);
				
				$futurResultat = array_merge($futurResultat, array($categorie));
				$futurResultat = array_merge($futurResultat, $this->flatChildren($categorie->getChildrens(), $level+1));
				
			}
			else
			{
				//echo $categorie->getLibelle(). ' n\'a pas d\'enfant (level : '.$level.')<br/>';
				$categorie->setLevel($level);
				$futurResultat = array_merge($futurResultat, array($categorie));
			}
		}
		return $futurResultat;
	}


	private function addChildrenAndSetParent(&$resultat, &$enfant)
	{
		foreach ($resultat as $categorie)
		{
			if ($enfant->getParent()->getId() == $categorie->getId())
			{
				$enfant->setParent($categorie);
				$categorie->addChildren($enfant);

			}
		}
	}
	

}
