<?php
namespace FGS\GestionComptesBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * CategorieMouvementFinancierRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class CategorieMouvementFinancierRepository extends EntityRepository
{

	public function getTreeCategories($cmf=null, $allowCmfId = false)
	{

		$queryBuilder	=	$this->getCategories();
		
		
		if (($cmf != null) && ( in_array($cmf->getType(), array(CategorieMouvementFinancier::TYPE_DEPENSE, CategorieMouvementFinancier::TYPE_REVENU))))
		{
			$queryBuilder
				->andWhere('cmf.type = ?1')
				->setParameter('1', $cmf->getType());
		}
		
		if (($cmf != null) && ($cmf->getId() != null) && (!$allowCmfId))
		{
			$queryBuilder
				->andWhere('cmf.id != ?2')
				->setParameter('2', $cmf->getId());
		}
		/*
		\Doctrine\Common\Util\Debug::dump($cmf);
		echo "\n type : ".$cmf->getType();
		echo "\n autorisation : ".$allowCmfId;
		echo "\n id : ".$cmf->getId()."\n";
		die($queryBuilder->getDQL());
		*/
		
		$resultat	= $queryBuilder->getQuery()->getResult();

		for ($key= count($resultat)-1; $key >=0; $key--)
		{
			$ligne=$resultat[$key];

			if ($ligne->getParent() != null) 
			{
				$this->addChildrenAndSetParent($resultat, $ligne);
				unset($resultat[$key]);
			}
			
			if ($ligne->getChildrens() instanceof  \Doctrine\ORM\PersistentCollection)
			{
				$ligne->getChildrens()->setInitialized(true);
			}
		}

		return array_reverse($resultat);
	}
	
	public function decreaseOrdreAfter(\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $parent, $ordre)
	{
		//TODO passer ca en query builder
		$this->_em
			->createQuery('
				UPDATE 		FGSGestionComptesBundle:CategorieMouvementFinancier cmf
				SET  		cmf.ordre	=	cmf.ordre - 1 
				WHERE 		cmf.parent 	= 	?1
				AND			cmf.ordre 	>	?2
				')
			->setParameter('1', $parent)
			->setParameter('2', $ordre)
			->execute();
	}
	
	public function increseOrdrePredecessor(\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $cmf)
	{
		$queryBuilder	= $this->_em->createQueryBuilder()
							->update('\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier', 'cmf')
							->set('cmf.ordre', 	'cmf.ordre+1')
							->where('cmf.ordre = ?1')
							->setParameter('1', $cmf->getOrdre()-1);
		
		return $this->addParentCondition($queryBuilder, $cmf)->getQuery()->getResult();
	}
	
	public function decreaseOrdreSuccessor(\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $cmf)
	{
			$queryBuilder	= $this->_em->createQueryBuilder()
								->update('\FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier', 'cmf')
								->set('cmf.ordre', 	'cmf.ordre-1')
								->where('cmf.ordre = ?1')
								->setParameter('1', $cmf->getOrdre()+1);
			
			return $this->addParentCondition($queryBuilder, $cmf)->getQuery()->execute();
	}
	
	
	public function getFlatTreeCategories($cmf=null, $allowCmfId=false)
	{
		return $this->flatChildren($this->getTreeCategories($cmf, $allowCmfId));
	}
	
	/**
	 * Permet d'ajouter en condition le parent d'une CatÃ©gorieMouvementFinancier
	 * 
	 * @param \Doctrine\ORM\QueryBuilder $queryBuilder
	 * @param \FGS\GestionComptesBundle\Entity\CategorieMouvementFinancier $cmf
	 * @return \Doctrine\ORM\QueryBuilder
	 */
	private function addParentCondition(\Doctrine\ORM\QueryBuilder $queryBuilder, $cmf)
	{
		if ($cmf->getParent() == null)
		{
			$queryBuilder
				->andWhere('cmf.parent is NULL');
		}
		else
		{
			$queryBuilder
				->andWhere('cmf.parent = ?2')
				->setParameter('2', $cmf->getParent());
		}
		return $queryBuilder;
	}
	

	private function getCategories()
	{
		return 	$this->_em->createQueryBuilder()
			->select('cmf')
			->from('FGSGestionComptesBundle:CategorieMouvementFinancier', 'cmf')
			->addOrderBy('cmf.parent', 'ASC')
			->addOrderBy('cmf.ordre', 'DESC');
	}

	private function flatChildren($treeCategorie, $level = 0)
	{
		$futurResultat = array();
		
		foreach ($treeCategorie as $categorie)
		{
			if ($categorie->hasChildren())
			{

				//echo $categorie->getLibelle(). ' a un enfant (level : '.$level.')<br/>';
				$categorie->setLevel($level);
				
				$futurResultat = array_merge($futurResultat, array($categorie));
				$futurResultat = array_merge($futurResultat, $this->flatChildren($categorie->getChildrens(), $level+1));
				
				
				
			}
			else
			{
				//echo $categorie->getLibelle(). ' n\'a pas d\'enfant (level : '.$level.')<br/>';
				$categorie->setLevel($level);
				$futurResultat = array_merge($futurResultat, array($categorie));
			}
		}
		return $futurResultat;
	}


	
	
	private function addChildrenAndSetParent(&$resultat, &$enfant)
	{
		foreach ($resultat as $categorie)
		{
			if ($enfant->getParent()->getId() == $categorie->getId())
			{
				$enfant->setParent($categorie);
				$categorie->addChildren($enfant);

			}
		}
	}
}
